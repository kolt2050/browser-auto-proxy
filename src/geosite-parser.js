const S = 4294967296, y = 12, E = typeof TextDecoder > "u" ? null : new TextDecoder("utf-8"), p = 0, c = 1, f = 2, u = 5; class C { constructor(t = new Uint8Array(16)) { this.buf = ArrayBuffer.isView(t) ? t : new Uint8Array(t), this.dataView = new DataView(this.buf.buffer), this.pos = 0, this.type = 0, this.length = this.buf.length } readFields(t, e, r = this.length) { for (; this.pos < r;) { const s = this.readVarint(), n = s >> 3, o = this.pos; this.type = s & 7, t(n, e, this), this.pos === o && this.skip(s) } return e } readMessage(t, e) { return this.readFields(t, e, this.readVarint() + this.pos) } readFixed32() { const t = this.dataView.getUint32(this.pos, !0); return this.pos += 4, t } readSFixed32() { const t = this.dataView.getInt32(this.pos, !0); return this.pos += 4, t } readFixed64() { const t = this.dataView.getUint32(this.pos, !0) + this.dataView.getUint32(this.pos + 4, !0) * 4294967296; return this.pos += 8, t } readSFixed64() { const t = this.dataView.getUint32(this.pos, !0) + this.dataView.getInt32(this.pos + 4, !0) * 4294967296; return this.pos += 8, t } readFloat() { const t = this.dataView.getFloat32(this.pos, !0); return this.pos += 4, t } readDouble() { const t = this.dataView.getFloat64(this.pos, !0); return this.pos += 8, t } readVarint(t) { const e = this.buf; let r, s; return s = e[this.pos++], r = s & 127, s < 128 || (s = e[this.pos++], r |= (s & 127) << 7, s < 128) || (s = e[this.pos++], r |= (s & 127) << 14, s < 128) || (s = e[this.pos++], r |= (s & 127) << 21, s < 128) ? r : (s = e[this.pos], r |= (s & 15) << 28, D(r, t, this)) } readVarint64() { return this.readVarint(!0) } readSVarint() { const t = this.readVarint(); return t % 2 === 1 ? (t + 1) / -2 : t / 2 } readBoolean() { return !!this.readVarint() } readString() { const t = this.readVarint() + this.pos, e = this.pos; return this.pos = t, t - e >= y && E ? E.decode(this.buf.subarray(e, t)) : N(this.buf, e, t) } readBytes() { const t = this.readVarint() + this.pos, e = this.buf.subarray(this.pos, t); return this.pos = t, e } readPackedVarint(t = [], e) { const r = this.readPackedEnd(); for (; this.pos < r;)t.push(this.readVarint(e)); return t } readPackedSVarint(t = []) { const e = this.readPackedEnd(); for (; this.pos < e;)t.push(this.readSVarint()); return t } readPackedBoolean(t = []) { const e = this.readPackedEnd(); for (; this.pos < e;)t.push(this.readBoolean()); return t } readPackedFloat(t = []) { const e = this.readPackedEnd(); for (; this.pos < e;)t.push(this.readFloat()); return t } readPackedDouble(t = []) { const e = this.readPackedEnd(); for (; this.pos < e;)t.push(this.readDouble()); return t } readPackedFixed32(t = []) { const e = this.readPackedEnd(); for (; this.pos < e;)t.push(this.readFixed32()); return t } readPackedSFixed32(t = []) { const e = this.readPackedEnd(); for (; this.pos < e;)t.push(this.readSFixed32()); return t } readPackedFixed64(t = []) { const e = this.readPackedEnd(); for (; this.pos < e;)t.push(this.readFixed64()); return t } readPackedSFixed64(t = []) { const e = this.readPackedEnd(); for (; this.pos < e;)t.push(this.readSFixed64()); return t } readPackedEnd() { return this.type === f ? this.readVarint() + this.pos : this.pos + 1 } skip(t) { const e = t & 7; if (e === p) for (; this.buf[this.pos++] > 127;); else if (e === f) this.pos = this.readVarint() + this.pos; else if (e === u) this.pos += 4; else if (e === c) this.pos += 8; else throw new Error(`Unimplemented type: ${e}`) } writeTag(t, e) { this.writeVarint(t << 3 | e) } finish() { return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length) } writeVarint(t) { if (t = +t || 0, t > 268435455 || t < 0) { m(t, this); return } this.realloc(4), this.buf[this.pos++] = t & 127 | (t > 127 ? 128 : 0), !(t <= 127) && (this.buf[this.pos++] = (t >>>= 7) & 127 | (t > 127 ? 128 : 0), !(t <= 127) && (this.buf[this.pos++] = (t >>>= 7) & 127 | (t > 127 ? 128 : 0), !(t <= 127) && (this.buf[this.pos++] = t >>> 7 & 127))) } realloc(t) { let e = this.length || 16; for (; e < this.pos + t;)e *= 2; if (e !== this.length) { const r = new Uint8Array(e); r.set(this.buf), this.buf = r, this.dataView = new DataView(r.buffer), this.length = e } } } function D(i, t, e) { const r = e.buf; let s, n; if (n = r[e.pos++], s = (n & 112) >> 4, n < 128 || (n = r[e.pos++], s |= (n & 127) << 3, n < 128) || (n = r[e.pos++], s |= (n & 127) << 10, n < 128) || (n = r[e.pos++], s |= (n & 127) << 17, n < 128) || (n = r[e.pos++], s |= (n & 127) << 24, n < 128) || (n = r[e.pos++], s |= (n & 1) << 31, n < 128)) return x(i, s, t); throw new Error("Expected varint not more than 10 bytes") } function x(i, t, e) { return e ? t * 4294967296 + (i >>> 0) : (t >>> 0) * 4294967296 + (i >>> 0) } function m(i, t) { let e, r; if (i >= 0 ? (e = i % 4294967296 | 0, r = i / 4294967296 | 0) : (e = ~(-i % 4294967296), r = ~(-i / 4294967296), e ^ 4294967295 ? e = e + 1 | 0 : (e = 0, r = r + 1 | 0)), i >= 18446744073709552e3 || i < -18446744073709552e3) throw new Error("Given varint doesn't fit into 10 bytes"); t.realloc(10), B(e, r, t), I(r, t) } function B(i, t, e) { e.buf[e.pos++] = i & 127 | 128, i >>>= 7, e.buf[e.pos++] = i & 127 | 128, i >>>= 7, e.buf[e.pos++] = i & 127 | 128, i >>>= 7, e.buf[e.pos++] = i & 127 | 128, i >>>= 7, e.buf[e.pos] = i & 127 } function I(i, t) { const e = (i & 7) << 4; t.buf[t.pos++] |= e | ((i >>>= 3) ? 128 : 0), i && (t.buf[t.pos++] = i & 127 | ((i >>>= 7) ? 128 : 0), i && (t.buf[t.pos++] = i & 127 | ((i >>>= 7) ? 128 : 0), i && (t.buf[t.pos++] = i & 127 | ((i >>>= 7) ? 128 : 0), i && (t.buf[t.pos++] = i & 127 | ((i >>>= 7) ? 128 : 0), i && (t.buf[t.pos++] = i & 127))))) } function N(i, t, e) { let r = "", s = t; for (; s < e;) { const n = i[s]; let o = null, h = n > 239 ? 4 : n > 223 ? 3 : n > 191 ? 2 : 1; if (s + h > e) break; let a, l, F; h === 1 ? n < 128 && (o = n) : h === 2 ? (a = i[s + 1], (a & 192) === 128 && (o = (n & 31) << 6 | a & 63, o <= 127 && (o = null))) : h === 3 ? (a = i[s + 1], l = i[s + 2], (a & 192) === 128 && (l & 192) === 128 && (o = (n & 15) << 12 | (a & 63) << 6 | l & 63, (o <= 2047 || o >= 55296 && o <= 57343) && (o = null))) : h === 4 && (a = i[s + 1], l = i[s + 2], F = i[s + 3], (a & 192) === 128 && (l & 192) === 128 && (F & 192) === 128 && (o = (n & 15) << 18 | (a & 63) << 12 | (l & 63) << 6 | F & 63, (o <= 65535 || o >= 1114112) && (o = null))), o === null ? (o = 65533, h = 1) : o > 65535 && (o -= 65536, r += String.fromCharCode(o >>> 10 & 1023 | 55296), o = 56320 | o & 1023), r += String.fromCharCode(o), s += h } return r } function H(i, t, e) { for (let r = 0, s, n; r < t.length; r++) { if (s = t.charCodeAt(r), s > 55295 && s < 57344) if (n) if (s < 56320) { i[e++] = 239, i[e++] = 191, i[e++] = 189, n = s; continue } else s = n - 55296 << 10 | s - 56320 | 65536, n = null; else { s > 56319 || r + 1 === t.length ? (i[e++] = 239, i[e++] = 191, i[e++] = 189) : n = s; continue } else n && (i[e++] = 239, i[e++] = 191, i[e++] = 189, n = null); s < 128 ? i[e++] = s : (s < 2048 ? i[e++] = s >> 6 | 192 : (s < 65536 ? i[e++] = s >> 12 | 224 : (i[e++] = s >> 18 | 240, i[e++] = s >> 12 & 63 | 128), i[e++] = s >> 6 & 63 | 128), i[e++] = s & 63 | 128) } return e } const g = { Plain: 0, Domain: 2, Full: 3 }; function $(i, t) { let e = i.readVarint() + i.pos, r = 0, s = ""; for (; i.pos < e;) { let n = i.readVarint(); switch (n >> 3) { case 1: r = i.readVarint(); break; case 2: s = i.readString(); break; default: i.skip(n & 7); break } } (r === g.Domain || r === g.Full || r === g.Plain) && t.push({ type: r, value: s }) } function Y(i, t, e) { let r = i.readVarint() + i.pos, s = "", n = []; for (; i.pos < r;) { let o = i.readVarint(); switch (o >> 3) { case 1: s = i.readString().toUpperCase(); break; case 2: $(i, n); break; default: i.skip(o & 7); break } } t.has(s) && (console.log(`Found category: ${s} with ${n.length} domains`), n.forEach(o => e.push(o.value))) } export function parseGeoSite(i, t = []) { const e = new C(i), r = new Set(t.map(n => n.toUpperCase())), s = []; for (; e.pos < e.length;) { let n = e.readVarint(); n >> 3 === 1 ? Y(e, r, s) : e.skip(n & 7) } return [...new Set(s)] }
